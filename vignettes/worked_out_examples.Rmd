---
title: "Worked-out example"
author: "Richel Bilderbeek"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Research demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This document shows some work-out examples.

These worked-out examples show:

  * the error if protractedness is absent
  * the error if protractedness strong
  * comparing these errors
  * the error if protractedness is absent for multiple replicates
  * the error if protractedness is strong for multiple replicates
  * comparing these errors

## Workflow

Every experiment has the following steps:

 * Starting up
 * Creating parameter files
 * Per parameter file:
   * Simulate one incipient species tree per parameter file
   * Once or more often, sample unique species from an incipient species tree
   * Per sampled species tree, add an outgroup
   * Simulate one or more alignments per species tree
   * Once or more often, let BEAST2 infer a posterior per alignment
 * Per two parameter files:
   * Compare original, sampled species tree, to the posterior

## Starting up

We will need to load some libraries:

```{r}
library(ape)
library(Cer2016)
library(ggplot2)
library(nLTT)
library(ribir)
```

## Creating parameter files

This worked-out example will show:

  * the error if protractedness is absent
  * the error if protractedness strong
  * comparing these errors
  * the error if protractedness is absent for multiple replicates
  * the error if protractedness is strong for multiple replicates
  * comparing these errors

For that, I will create four parameter files:

  * `toy_example_1.RDa`: protractedness is absent
  * `toy_example_2.RDa`: protractedness strong
  * `toy_example_3.RDa`: protractedness is absent for multiple replicates
  * `toy_example_4.RDa`: protractedness is strong for multiple replicates

Here, we create the four parameter filenames:

```{r}
filenames = c(
  "toy_example_1.RDa", 
  "toy_example_2.RDa", 
  "toy_example_3.RDa", 
  "toy_example_4.RDa"
)
```

To be sure to have a fresh analysis, we delete the files if they exist:

```{r}
#for (filename in filenames) {
#  if (file.exists(filename)) {
#    file.remove(filename)
#  }
#}
```

Now the parameter files are created with the desired parameters:

```{r}
rng_seeds <- seq(1,4)
sirgs <- rep(0.5, times = 4)
siris <- rep(0.5, times = 4)
scrs <- c(1.0e6, 1.0e-1, 1.0e6, 1.0e-1)
ergs <- rep(0.1, times = 4)
eris <- rep(0.1, times = 4)
ages <- rep(5, times = 4)
n_species_trees_sampleses <- c(1, 1, 2, 2)
mutation_rates <- rep(0.01, times = 4)
n_alignmentses <- c(1, 1, 2, 2)
sequence_lengths <- rep(1000, times = 4)
mcmc_chainlengths <- rep(10000, times = 4)
n_beast_runses <- c(1, 1, 2, 2)
for (i in seq(1, 4)) {
  save_parameters_to_file(
    rng_seed = rng_seeds[i],
    sirg = sirgs[i],
    siri = siris[i],
    scr = scrs[i],
    erg = ergs[i],
    eri = eris[i],
    age = ages[i],
    n_species_trees_samples = n_species_trees_sampleses[i],
    mutation_rate = mutation_rates[i],
    n_alignments = n_alignmentses[i],
    sequence_length = sequence_lengths[i],
    mcmc_chainlength = mcmc_chainlengths[i],
    n_beast_runs = n_beast_runses[i],
    filename = filenames[i]
  )  
}
```

  * `toy_example_1.RDa`: protractedness is absent, thus speciation completion rate is high, in this case `1.0e6`
  * `toy_example_2.RDa`: protractedness strong, thus speciation completion rate is low, in this case `1.0e-1`
  * `toy_example_3.RDa`: protractedness is absent for multiple replicates, thus number of sampled species trees, alignments per species trees, and BEAST2 runs are all 2
  * `toy_example_4.RDa`: protractedness is strong for multiple replicates,  thus number of sampled species trees, alignments per species trees, and   BEAST2 runs are all 2
  
Here the parameters are shown in a nicer format:

```{r}
show_parameter_files(filenames)
```

The parameter settings used in this example are identical, 
except for their speciation completion rate and number of replicates. 

The experimental setup of this research has multiple steps, which we will follow closely here. 

These worked-out examples show the data produced in its raw form and does not care too much about aesthetics.

## Example 1: Weak protractedness

This example answers the question: what is the base level error of 
the analyses in this research?

The base level error can be obtained by using parameters for a 
constant-rate birth-death model. All tools used assume this model, 
but there will be noise (thus error) added in the process. 

The parameter settings of example 1 have a high speciation 
completion rate \lambda, which makes the constant-rate 
protracted speciation model fall back to a 
constant-rate birth-death model, 
as incipient species become good species (close to) instantaneously.

### Simulate one incipient species tree per parameter file

Here we simulate the 'true' incipient species tree:

```{r}
filename <- filenames[1]
testit::assert(is_valid_file(filename))
add_pbd_output(filename)
```

This is how the incipient species tree looks like:

```{r}
colors <- setNames(c("gray","black"),c("i","g"))
testit::assert(length(read_file(filename)$pbd_output$igtree.extant$tip.label) > 0)
phytools::plotSimmap(
  read_file(filename)$pbd_output$igtree.extant, 
  colors = colors
)
```

The taxon labels are S[genus]-[species]-[sub-species]'.

Now, we plot the nLTT plot of the same phylogeny in two ways:
 
 * using the `ribir` package its `get_nltt_values` function and `ggplot2`
 * using the `nLTT` package its `nLTT.plot` function

I show both because `ribir` can average multiple nLTT plots, where
`nLTT` is an established package. The results should be the same:

```{r}
# using the `ribir` package its `get_nltt_values` function and `ggplot2`
nltt_values <- get_nltt_values(
  phylogenies = list(read_file(filename)$pbd_output$tree), 
  dt = 0.001
)
qplot(
  t, nltt, data = nltt_values, geom = "blank", ylim = c(0,1),
  main = "Example #1"
) + stat_summary(
  fun.data = "mean_cl_boot", color = "red", geom = "smooth"
)

# using the `nLTT` package its `nLTT.plot` function
nLTT::nLTT.plot(read_file(filename)$pbd_output$tree)
```

The `get_nltt_values` function assumes a list of phylogenies, so
in this code snippet I create a list of one phylogeny.


### Once or more often, sample unique species from an incipient species tree. Also add an outgroup

From that incipient species tree, 
we create a species tree by sampling one individual 
per incipient species. Because speciation is for a 
constant-rate birth death model, there exist no multiple individuals 
per species. To being able to root our phylogenies in later steps, an outgroup is added as well.

```{r}
add_species_trees_with_outgroup(filename)  
```

Here we observe the sample species tree:

```{r}
plot_species_tree_with_outgroup(filename)
```

Note that in example #3, there will be multiple sampled
species trees. 

### Simulate one or more alignments per species tree

Knowing the evolutionary distances between species, DNA sequence alignments can be simulated fitting the tree. To do so, the parameters for sequence length and mutation rate are used. Note that this research assumes a simple Jukes-Cantor model, and does so as well in later steps.

```{r}
add_alignments(filename)  
```

Here:

```{r}
plot_alignments(filename)
```




   * Once or more often, let BEAST2 infer a posterior per alignment
 * Per two parameter files:
   * Compare original, sampled species tree, to the posterior
