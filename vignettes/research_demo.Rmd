---
title: "Research demo"
author: "Richel Bilderbeek"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Research demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This document describes my research. It does so by
showing the workflow for toy examples.

## Workflow

Every experiment has the following steps:

 * Starting up
 * Creating parameter files
 * Simulate one incipient species tree per parameter file
 * Once or more often, sample unique species from an incipient species tree
 * Per sampled species tree, add an outgroup
 * Simulate one or more alignments per species tree
 * Once or more often, let BEAST2 infer a posterior per alignment
 * Compare original, sampled species tree, to the posterior

## Starting up

## Creating parameter files

We will need to load some libraries:

```{r}
library(Cer2016)
library(ape)
```


We create four parameter files:

```{r}
filenames <- c(
  "toy_example_1.RDa", 
  "toy_example_2.RDa", 
  "toy_example_3.RDa", 
  "toy_example_4.RDa"
)
```

Now the parameter files are created:

```{r}
create_test_parameter_files(filenames = filenames)
```

Here we can view them:

```{r}
knitr::kable(collect_parameters(filenames = filenames))
```

Note that they all have a different random number generator seed. Because
they do have different other parameters, this is no problem.


### Simulate one incipient species tree per parameter file

Here we simulate the 'true' incipient species tree:

```{r}
for (filename in filenames) {
  add_pbd_output(filename)  
}
```

This is how these look like, both the incipient species phylogenies and an nLTT plots:

```{r}
colors <- stats::setNames(c("gray", "black"), c("i", "g"))

for (filename in filenames) {
  testit::assert(is_valid_file(filename))
  testit::assert(length(read_file(filename)$pbd_output$igtree.extant$tip.label) > 0)
  print(filename)
  phytools::plotSimmap(
    read_file(filename)$pbd_output$igtree.extant, 
    colors = colors
  )
  nLTT::nltt_plot(read_file(filename)$pbd_output$tree)
}
```

## Once or more often, sample unique species from an incipient species tree. Then, per sampled species tree, add an outgroup

Here we simulate the 'true' incipient species tree:

```{r}
for (filename in filenames) {
  add_species_trees(filename, verbose = FALSE)  
}
```

Those are shown here. Note that run 1 and 2 have no replicate and
thus produce only one sampled tree.

```{r}
for (filename in filenames) {
  print(filename)
  plot_species_tree(filename)
}
```


## Add alignments

```{r}
for (filename in filenames) {
  add_alignments(filename)  
}
```

```{r}
for (filename in filenames) {
  print(filename)
  plot_alignments(filename)
}
```

## Add posteriors

```{r add_posteriors}
for (filename in filenames) {
  add_posteriors(
    filename, 
    skip_if_output_present = TRUE
  )
}
```

```{r}
for (filename in filenames) {
  print(filename)
  plot_posterior_samples(filename)
  plot_posterior_sample_nltts(filename)
}
```

Let's view the two posteriors of the first two files:

```{r}
plot_posterior_nltts(filenames[1])
plot_posterior_nltts(filenames[2])
```

The third and fourth parameter files have had two BEAST2 runs per alignment.
We can see how similar these are:

```{r}
plot_posterior_nltts(filenames[3])
plot_posterior_nltts(filenames[4])
```


## Show the posterior again of the second file

```{r}
filename <- filenames[2]
n_beast_runs <- extract_nppa(read_file(filename))
posteriors <- get_posteriors(read_file(filename))
testit::assert(length(posteriors) == 2 * n_beast_runs)
testit::assert(is_posterior(Cer2016::get_posterior(file = read_file(filename), sti = 1, ai = 1, pi = 1)))
testit::assert(is_posterior(Cer2016::get_posterior(file = read_file(filename), sti = 1, ai = 1, pi = 2)))
testit::assert(is_posterior(Cer2016::get_posterior(file = read_file(filename), sti = 2, ai = 1, pi = 1)))
testit::assert(is_posterior(Cer2016::get_posterior(file = read_file(filename), sti = 2, ai = 1, pi = 2)))

phylogenies_1 <- Cer2016::get_posterior(file = read_file(filename), sti = 1, ai = 1, pi = 1)
phylogenies_2 <- Cer2016::get_posterior(file = read_file(filename), sti = 1, ai = 1, pi = 2)
phylogenies_3 <- Cer2016::get_posterior(file = read_file(filename), sti = 2, ai = 1, pi = 1)
phylogenies_4 <- Cer2016::get_posterior(file = read_file(filename), sti = 2, ai = 1, pi = 2)

testit::assert(length(phylogenies_1) > 0)
testit::assert(length(phylogenies_2) > 0)
testit::assert(length(phylogenies_3) > 0)
testit::assert(length(phylogenies_4) > 0)
```

Here another hack: to get the `densiTree` function working, phylogenies must be of class multiphylo.
Let it be so:

```{r}
class(phylogenies_1) <- "multiPhylo"
class(phylogenies_2) <- "multiPhylo"
class(phylogenies_3) <- "multiPhylo"
class(phylogenies_4) <- "multiPhylo"
```

Displaying first posterior of the `youngest` species tree:

```{r fig.width = 7, fig.height = 7}
phangorn::densiTree(
  phylogenies_1, 
  type = "cladogram", 
  alpha = 1
)
```

Displaying second posterior of the `youngest` species tree:

```{r fig.width = 7, fig.height = 7}
phangorn::densiTree(
  phylogenies_2, 
  type = "cladogram", 
  alpha = 1
)
```

Displaying first posterior of the `oldest` species tree:

```{r fig.width = 7, fig.height = 7}
phangorn::densiTree(
  phylogenies_3, 
  type = "cladogram", 
  alpha = 1
)
```

Displaying second posterior of the `oldest` species tree:

```{r fig.width = 7, fig.height = 7}
phangorn::densiTree(
  phylogenies_4, 
  type = "cladogram", 
  alpha = 1
)
```
